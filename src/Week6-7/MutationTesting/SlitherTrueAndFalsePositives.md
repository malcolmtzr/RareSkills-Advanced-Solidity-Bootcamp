# True and False Positives

## Reentrancies
### UniswapFactory (Week3-5)
#### `createPair`
```
    function createPair(address tokenA, address tokenB) external returns (address pair) {
        require(tokenA != tokenB, "UniswapFactory: Cannot create pair with same token");
        //sorts token addresses to create deterministic pair, ensures uniqueness in contract
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), "UniswapFacory: Cannot create pair with zero address");

        bytes32 pairKey = keccak256(abi.encodePacked(token0, token1));
        require(getPair[pairKey] == address(0), "UniswapFactory: Pair already exists in contract");

        bytes memory contractBytecode = type(UniswapPair).creationCode;
        bytes32 create2Salt = keccak256(abi.encodePacked(token0, token1));
        assembly {
            pair :=
                create2(
                    0,
                    add(contractBytecode, 0x20), //advance to skip length in first 32 bytes
                    mload(contractBytecode), //length of contract bytecode
                    create2Salt
                )
        }
        UniswapPair(pair).initialize(token0, token1);
        getPair[pairKey] = pair;
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }
```
The reentrancy detected in the `createPair` function is a false positive. An external call is made through `Uniswap(pair).initialize(token0, token1)` with the intention to create a new pair. The `pair` contract was generated by the factory contract through `create2` so the pair contract would be in a "fresh" state and there are no possibilities of having any pending calls or states, in which the contract's state is not fully finalized. The pair contract is also a trusted contract in the context of this function.

It also highlights that state variables are written after the `initialize` external call, which in this case though is not an issue, is a good point to adhere to as with the Checks-Effects-Interactions pattern. The updates to the `getPair` mapping and `allPairs` array should be done before the external call.

It mentions that `getPair` could be used for cross function reentrancies, but in this case is a false positive based on the context of `createPair`.

### StakingNFT (Week2)
#### `withdrawNFT`
```
    function withdrawNFT(uint256 _tokenId) external nonReentrant whenNotPaused {
        require(msg.sender == getOriginalOwner(_tokenId), "Only the original owner can withdraw");

        if (!(block.timestamp - getClaimTime(_tokenId) < interval)) {
            rewardTokenContract.mintRewards(msg.sender, MINT_AMOUNT);
            emit MintRewards(msg.sender, MINT_AMOUNT);
        }

        //set the claimTime bits to 0
        //THIS MUST BE SET TO ZERO TO PREVENT REENTRANCY ATTACKS.
        stakingInfo[_tokenId] = 0;

        someNFTContract.safeTransferFrom(address(this), msg.sender, _tokenId);

        emit WithdrawNFT(msg.sender, _tokenId);
    }
```
Reentrancy was detected in the `withdrawNFT` function, and this is a false positive. The function makes an external call to the reward token which is a trusted ERC20 contract for rewarding users who stake their NFT in the staking contract. The `mintRewards` function of the ERC20 contract is also only callable by the staking contract. So this is not an issue.

It mentions that the `stakingInfo` mapping could be used in cross function reentrancies through the `getClaimTime`, `getOriginalOwner`, and `onERC721Received` functions. This is also a false positive. Both `getClaimTime` and `getOriginalOwner` are view functions and they dont alter the state of `stakingInfo`. The `onERC721Received` function alters the state of `stakingInfo` however, this function is only callable by the trusted ERC721 contract so there is not an issue.

## Local Variable Shadowing
### StakingNFT (Week2)
```
    function _packStakingData(address _owner) private view returns (uint256 result) {
        assembly {
            //mask owner to lower 160 bits
            _owner := and(_owner, _BITMASK_ADDRESS)
            //`owner` | (block.timestamp << 160)
            result := or(_owner, shl(_BITPOS_START_TIMESTAMP, timestamp()))
        }
    }

    function getOriginalOwner(uint256 _tokenId) public view returns (address) {
        address owner = address(uint160(stakingInfo[_tokenId] & _BITMASK_ADDRESS));
        return owner;
    }
```
Slither warns that the `_owner` and `owner` variables in the `_packStakingData` and `getOriginalOwner` functions are shadowing `Ownable._owner` and `Ownable.owner` respectively. These are false positives because `_owner` and `owner` variables are scoped within their respective functions and thus do not interfere with the `Ownable` contract's storage variables.

## Missing Zero Address Validation
