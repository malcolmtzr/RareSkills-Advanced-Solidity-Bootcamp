# True and False Positives

## Arbitrary `from` in `transferFrom`
### UniswapPair (Week3-5)
#### `flashLoan`
```
    function flashLoan(
        IERC3156FlashBorrower receiver,
        address token,
        uint256 amount,
        bytes calldata data
    )
        external
        override
        nonReentrant
        returns (bool)
    {
        require(token == token0 || token == token1, "UniswapPair: token must be either token0 or token1");
        require(amount <= maxFlashLoan(token), "UniswapPair: amount exceeds maxFlashLoan");
        uint256 fee = _flashFee(amount);
        SafeTransferLib.safeTransfer(token, address(receiver), amount); //loan out
        //receiver callback
        require(
            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == CALLBACK_SUCCESS,
            "UniswapPair: flash loan callback failed"
        );
        SafeTransferLib.safeTransferFrom(token, address(receiver), address(this), amount + fee); //repays loan

        emit FlashLoan(address(receiver), token, amount, fee, data);
        return true;
    }
```
The warning here is regarding the use of an arbitray `from` address: `receiver` in `SafeTransferLib.safeTransferFrom(token, address(receiver), address(this), amount + fee)`. The `receiver` is the address that receives the flash loan and is expected to pay the loan back with fees in the same atomic transaction. Slither highlights this because the `receiver` can be any address,  and it has control and can potentially manipulate the transaction.

As the `receiver` can potentially be any borrower contract that implements `IERC3156FlashBorrower` and simply returns `keccak256("ERC3156FlashBorrower.onFlashLoan")`, there is a risk that a malicious borrower contract can simply implement this in an attempt to re-enter the Uniswap pair contract. This can happen before the return statement is executed in the `receiver`. The malicious borrower contract could also have a `fallback` or `receive` function designed to call back into the pair contract. To mitigate this, we can implement checks to ensure that the `receiver` is a trusted contract address.

In this context, the vulnerability can be considered a ***false positive***, as all external/public state modifying functions in the pair contract are `nonReentrant`.

Separately, the requirement for the flash borrower to return keccak256("ERC3156FlashBorrower.onFlashLoan") in ERC-3156 addresses a specific security concern. In a scenario where a contract with a fallback function has approved a flash loan, there's a risk of the contract being exploited through repeated flash loan initiations. If the victim contract does not have an `onFlashLoan()`` function defined, the fallback function is triggered, and a malicious lender can proceed to withdraw tokens from the victim, and potentially drain the victim contract. This requirement ensures that the contract receiving the loan is intended to handle flash loans (i.e., it has an onFlashLoan function implemented) and is not just a contract with a generic fallback function. This mechanism doesnt stop the initiation of a flash loan to any contract, but it enforces that only contracts prepared to handle and repay flash loans correctly will complete the transaction successfully.

## Reentrancies
### UniswapFactory (Week3-5)
#### `createPair`
```
    function createPair(address tokenA, address tokenB) external returns (address pair) {
        require(tokenA != tokenB, "UniswapFactory: Cannot create pair with same token");
        //sorts token addresses to create deterministic pair, ensures uniqueness in contract
        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
        require(token0 != address(0), "UniswapFacory: Cannot create pair with zero address");

        bytes32 pairKey = keccak256(abi.encodePacked(token0, token1));
        require(getPair[pairKey] == address(0), "UniswapFactory: Pair already exists in contract");

        bytes memory contractBytecode = type(UniswapPair).creationCode;
        bytes32 create2Salt = keccak256(abi.encodePacked(token0, token1));
        assembly {
            pair :=
                create2(
                    0,
                    add(contractBytecode, 0x20), //advance to skip length in first 32 bytes
                    mload(contractBytecode), //length of contract bytecode
                    create2Salt
                )
        }
        UniswapPair(pair).initialize(token0, token1);
        getPair[pairKey] = pair;
        allPairs.push(pair);
        emit PairCreated(token0, token1, pair, allPairs.length);
    }
```
The reentrancy detected in the `createPair` function is a ***false positive***. An external call is made through `Uniswap(pair).initialize(token0, token1)` with the intention to create a new pair. The `pair` contract was generated by the factory contract through `create2` so the pair contract would be in a "fresh" state and there are no possibilities of having any pending calls or states, in which the contract's state is not fully finalized. The pair contract is also a trusted contract in the context of this function.

It also highlights that state variables are written after the `initialize` external call, which in this case though is not an issue, is a good point to adhere to as with the Checks-Effects-Interactions pattern. The updates to the `getPair` mapping and `allPairs` array should be done before the external call.

It mentions that `getPair` could be used for cross function reentrancies, but in this case is a false positive based on the context of `createPair`.

### UniswapPair (Week3-5)
#### `mint`
```
    function mint(
        address _token0Arg,
        address _token1Arg,
        uint256 amount0Specified,
        uint256 amount1Specified,
        uint256 amount0Min,
        uint256 amount1Min,
        uint256 deadline
    )
        external
        nonReentrant
        timeLock(deadline)
        returns (uint256)
    {
        require(_token0Arg != address(0) && _token1Arg != address(0), "UniswapPair: ZERO_ADDRESS");
        (address _token0, address _token1) = _checkTokens(_token0Arg, _token1Arg);

        (uint112 _reserve0, uint112 _reserve1,) = getReserves();
        (uint256 amount0Adjusted, uint256 amount1Adjusted) =
            _calculateAdjustedAmounts(_reserve0, _reserve1, amount0Specified, amount1Specified, amount0Min, amount1Min);

        //Transfer tokens from liquidity provider to pool
        SafeTransferLib.safeTransferFrom(_token0, msg.sender, address(this), amount0Adjusted);
        SafeTransferLib.safeTransferFrom(_token1, msg.sender, address(this), amount1Adjusted);

        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        //Get amount of tokens sent to pool by liquidity provider
        uint256 amount0 = balance0 - _reserve0;
        uint256 amount1 = balance1 - _reserve1;
        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint256 _totalSupply = totalSupply(); //must be defined here since totalSupply can update in _mintFee

        //Calculate amount of LP to mint to liquidity provider
        uint256 liquidity;
        if (_totalSupply == 0) {
            liquidity = FixedPointMathLib.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;
            _mint(address(0), MINIMUM_LIQUIDITY); //permanently lock the first MINIMUM_LIQUIDITY LP tokens
        } else {
            liquidity =
                FixedPointMathLib.min((amount0 * _totalSupply) / _reserve0, (amount1 * _totalSupply) / _reserve1);
        }
        require(liquidity > 0, "UniswapPair: INSUFFICIENT_LIQUIDITY_MINTED");
        _mint(msg.sender, liquidity);

        // Update reserves with current balances
        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) {
            kLast = uint256(reserve0) * reserve1; //reserve0 and reserve1 are updated in _update
        }

        emit Mint(msg.sender, amount0, amount1);
        return liquidity;
    }
```

Slither detects a potential reentrancy in the `mint` function, where an external call is made in the `_checkTokens` private function. The `_checkTokens` function makes an external call to the `UniswapFactory` contract to sort the pair of token address inputs and to check if the pair is already created. Since the factory contract is a trusted contract, this is a ***false positive***.

It also warns that state variables are updated after the external call: `_update` and `kLast`, but this can be ignored due to checking if the pair has been created when a user is adding liquidity. The `mint` function is also `nonReentrant` so this is acceptable.

### StakingNFT (Week2)
#### `withdrawNFT`
```
    function withdrawNFT(uint256 _tokenId) external nonReentrant whenNotPaused {
        require(msg.sender == getOriginalOwner(_tokenId), "Only the original owner can withdraw");

        if (!(block.timestamp - getClaimTime(_tokenId) < interval)) {
            rewardTokenContract.mintRewards(msg.sender, MINT_AMOUNT);
            emit MintRewards(msg.sender, MINT_AMOUNT);
        }

        //set the claimTime bits to 0
        //THIS MUST BE SET TO ZERO TO PREVENT REENTRANCY ATTACKS.
        stakingInfo[_tokenId] = 0;

        someNFTContract.safeTransferFrom(address(this), msg.sender, _tokenId);

        emit WithdrawNFT(msg.sender, _tokenId);
    }
```
Reentrancy was detected in the `withdrawNFT` function, and this is a ***false positive***. The function makes an external call to the reward token which is a trusted ERC20 contract for rewarding users who stake their NFT in the staking contract. The `mintRewards` function of the ERC20 contract is also only callable by the staking contract. So this is not an issue.

It mentions that the `stakingInfo` mapping could be used in cross function reentrancies through the `getClaimTime`, `getOriginalOwner`, and `onERC721Received` functions. This is also a false positive. Both `getClaimTime` and `getOriginalOwner` are view functions and they dont alter the state of `stakingInfo`. The `onERC721Received` function alters the state of `stakingInfo` however, this function is only callable by the trusted ERC721 contract so there is not an issue.

## Local Variable Shadowing
### StakingNFT (Week2)
```
    function _packStakingData(address _owner) private view returns (uint256 result) {
        assembly {
            //mask owner to lower 160 bits
            _owner := and(_owner, _BITMASK_ADDRESS)
            //`owner` | (block.timestamp << 160)
            result := or(_owner, shl(_BITPOS_START_TIMESTAMP, timestamp()))
        }
    }

    function getOriginalOwner(uint256 _tokenId) public view returns (address) {
        address owner = address(uint160(stakingInfo[_tokenId] & _BITMASK_ADDRESS));
        return owner;
    }
```
Slither warns that the `_owner` and `owner` variables in the `_packStakingData` and `getOriginalOwner` functions are shadowing `Ownable._owner` and `Ownable.owner` respectively. These are false positives because `_owner` and `owner` variables are scoped within their respective functions and thus do not interfere with the `Ownable` contract's storage variables.

## Missing Zero Address Validation
### UniswapFactory (Week3-5)
#### `setFeeTo`
```
    function setFeeTo(address _feeTo) external {
        require(msg.sender == feeToSetter, "UniswapFactory: Not authorized to set feeTo");
        feeTo = _feeTo;
    }
```
This is a ***false positive*** because a zero address for the `feeTo` address would mean that fees are not turned on in the `UniswapPair` contract.

## Block timestamp 
There are several detectors concerning the use of `block.timestamp` for comparison, and the reason is that `block.timestamp` can be manipulated. This is no longer an issue with Proof-of-Stake, as `block.timestamp` is controlled by validators and they agree on the block timestamp before it can be finalized. 

## Other Detectors
Slither detects assembly usage in `StakingNFT`, `IsPrimeOnSteroids`, `UniswapFactory`, but this is not of consequence.

Slither detects different versions of Solidity in the contracts in the `src` and the `lib` directories, but this is not of consequence. Contracts written in `src` are strictly using Solidity 0.8.21. It also suggests 0.8.21 is a version too recent to be trusted but this can be ignored.

There are some warnings regarding naming conventions in mixedCase as there are non-private variables using `_` at the beginning of their names, but this can be ignored. Can also ignore variable names too similar warnings.

There are some detectors concerning state variable that could be declared immutable, in `StakingNFT`, `IsPrimeOnSteroids` and `UniswapPair`. These state variables have been changed to `immutable`, with the exception of the `IsPrimeOnSteroids` contract as assembly access to immutable variables is not supported.